#! /usr/bin/env python
# -*- coding: utf-8 -*-

import sqlite3 , sys, random, os, argparse, pickle
import numpy as np

def parse_args():
    parser = argparse.ArgumentParser(description='Fill points randomly for the moment')
    parser.add_argument('--input-file','-i', dest='input_file', action='store', 
            default='test.db',  help='Name of input date base file',required=True)
    parser.add_argument('--pickle-in',dest='pickle_in', action='store',nargs='+' ,
              help='Name of pickled file containing (a) points(s)',required=True)
    return parser.parse_args()


def dump_rows(con,cur,rows):
    #NOTE: this takes rows without index
    # the index should be generated by sql
    question_marks=','.join(['?']*len(rows[0]))
    cur.executemany('insert into points values(null,{})'.format(question_marks), rows )
    #commit
    con.commit()

def get_columns_and_observable_ids(con,cur):
    cur.execute('select point_column, obs_id_field1 , obs_id_field2 from obs_id_lookup')
    obs_id_lookup=cur.fetchall()
    columns=[]
    oids={}
    for col, id1, id2 in obs_id_lookup:
        columns.append(col)
        oids[col]=(id1,id2)
    return columns, oids

def mc_points_to_rows(con,cur,points,collection_id=1):
    #Here starts the niceness!
    obs_columns, mc_obs_ids = get_columns_and_observable_ids(con,cur)
    rows=[]
    for point in points:
        #The following checks whether
        #   the point contains all the information in the lookup table, 
        #   the lookup table is complete
        observables=[]
        for col in obs_columns:
            observable=point.get(mc_obs_ids[col],-123456789.)
            observables.append(observable) 
            if observable==-123456789.:
                print("WARNING: presumably point does not contain key {}".format(mc_obs_ids[col]))
        if len(point) > len(obs_columns):
            print("WARNING: DATABASE IS MISSING COLUMNS")
            print("         FIXME: A function is needed to take care of this")
        #Et voila: le point :D :D
        rows.append(tuple([collection_id]+observables))
    return rows

if __name__=="__main__" :
    con = None
    args= parse_args()
    try:
        #connection and cursor
        con=sqlite3.connect(args.input_file)
        cur=con.cursor()
        #get point from pickles file
        points=[]
        for fname in args.pickle_in:
            with open(fname,'rb') as pickle_file:
                points.append(pickle.load(pickle_file))
        rows=mc_points_to_rows(con,cur,points)
        dump_rows(con,cur,rows)
    
    # Finalise ...
    except sqlite3.Error as e:
        if con:
            con.rollback()
        print('ERROR: {}'.format(e.args[0]))
        sys.exit()
    finally:
        if con:
            con.close()

